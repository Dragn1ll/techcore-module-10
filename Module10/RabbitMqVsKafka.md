#### RabbitMQ

Это классический message broker с моделями очередей и exchange’ов. Продюсер кладёт сообщения в брокер, брокер по 
routing key и binding’ам решает, в какие очереди их доставить, а потребители читают из своих очередей и **подтверждают** 
сообщения. После ack сообщение считается доставленным и, как правило, удаляется. Это хорошо ложится на паттерны 
**команд** и **событий для онлайн‑обработки**:
- "Оформить заказ", "Списать деньги", "Отправить email" — типичные команды, которые кому‑то надо выполнить ровно один раз.
- Главное — **гарантированная доставка** и гибкая маршрутизация: `topic / fanout / direct`‑exchange, приоритетные 
очереди, отложенная доставка, DLQ и т.п.

Идея: брокер знает много, клиенты — простые. Продюсеру и консьюмеру не нужно задумываться о маршрутизации, ретраях, 
dlq — это во многом конфигурация брокера и обвязка вроде MassTransit.

Минус такого подхода — сложная топология и связность: при большом количестве очередей, биндингов и потребителей 
архитектура обрастает "проводами", которые нужно тщательно проектировать и обслуживать.

#### Kafka

Это не столько очередь, сколько **распределённый лог событий**. Данные пишутся в **топики**, каждый топик разбит на 
партиции — упорядоченные immutable‑лог‑файлы. Продюсер просто пишет в лог, брокер почти не думает, он не роутит по 
сложным правилам, а тупо пишет в конец файла и реплицирует.

Ключевая особенность: **сообщения не удаляются после чтения** (удаляются по политике retention: по времени или размеру). 
Каждый consumer‑group хранит **offset** — "насколько далеко мы прочитали". Это создаёт важные следствия:
- Один и тот же поток событий могут независимо читать десятки consumer‑групп, каждая — в своём темпе.
- Можно **перечитывать историю** (replay) для реконструкции состояния, обучения моделей, подключения новых сервисов 
"задним числом".
- Масштабирование — через количество партиций и consumer‑групп: внутри группы партиции распределяются между инстансами, 
обеспечивая параллелизм.

Здесь брокер простой, но **клиент обязан быть умным**: заниматься распределением нагрузки, хранением offset’ов, 
балансировкой, обработкой ретраев. Для .NET этим часто занимается Confluent. Kafka или обвязки поверх него.

#### Какой инструмент куда?

- RabbitMQ как message bus:
    - микросервисы, бизнес‑команды, надёжная доставка, гибкая маршрутизация;
    - low‑latency запрос‑ответ, RPC поверх очередей, сложные топологии с routing‑key’ями.

- Kafka как event stream:
    - телеметрия, логирование, activity‑stream, аналитика, CDC из БД;
    - high‑throughput ingest, real‑time stream processing (Flink, Kafka Streams, ksqlDB);
    - построение **event‑sourcing** и возможности "перемотки времени".